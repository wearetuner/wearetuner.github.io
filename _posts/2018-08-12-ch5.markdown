---
layout: post
title:  "Chapter 05. 가비지 컬렉션 입문"
date:   2018-08-12 21:30:28 +0900
categories: java performance tuning
---
- 시리얼 컬렉터, 처리율 컬렉터, 동시병렬 컬렉터, G1컬렉터
- 가비지 컬렉터는 멀티스레드를 쓰기때문에 싱글 쓰레드일 경우 동작하는데 더 원활하다.
- 애플리케이션 스레드가 동작하면서 일부 부분집합으로 쪼개어진 힙(영 제네레이션)이 메모리 영역을 모두 사용하면 더 이상 사용하지 않는 메모리를 사용하고 있는 메모리의 인접 메모리로 이동 후(올드 제네레이션) 이동한 주소 포인트를 가리킨다. 이를 마이너GC라고 부른다. 마이너GC는 할당된 영역만 메모리를 비우고 사용하는 메모리로 압축시키기 때문에 애플리케이션 이동 주기가 짧고 빠르다.
- 나눠진 영역없이 모든 애플리케이션 스레드를 모두 중지한후 사용되지 않는 객체를 찾아서 메모리를 해제하고 힙을 압축하는 과정을 풀GC라고 부른다.
- CMS와 G1 컬렉터는 미사용 객체를 훑어보는 동안 애플리케이션 스레드를 멈추지 않고 처리하기 때문에 동시 병렬 컬렉터라고 부르며 저중단 컬렉터라고도 부른다. 다만 CPU사용율이 늘어나는 것이 기존의 컬렉터(애플리케이션 스레드 중단 시간)와의 트레이드 오프 이다.

- GC알고리즘
- 시리얼 컬렉터 : 싱글 스레드일경우 가장 기본적으로 사용되는 가비지 컬렉터이며 메모리를 해제 시키기 위한 스레드가 수행되기 위해선 애플리케이션 스레드가 멈춰있는다. (-XX:+UseSerialGC로 활성화)
- 처리율 컬렉터 : 다중CPU유닉스 머신이나 64비트 JVM에서 디폴트 컬렉터이다. 영 제네레이션과 올드 제네레이션을 처리할때 여러개의 스레드를 사용하기 때문에 마이너GC가 빨라진다.(-XX:+UseParallelOldGC로 활성화)
- CMS컬렉터 : CMS컬렉터는 마이너GC동안 애클리케이션 스레드를 전부 중지 시키고 여러개의 스레드로 수행한다. 애플리케이션 스레드를 멈추지 않고 주기적으로 올드 제너레이션을 살치고 미사용 개체를 폐기하는데 하나 이상의 백그라운드 스레드를 사용한다. 하지만 주기적으로 올드 제네레이션을 관찰하고 폐기하고 애플리케이션 스레드가 돌기 때문에 CPU사용율이 높다. (-XX:+UseConcMarkSweepGC, -XX:+UseParNewGC로 활성화)
- G1컬렉터: 큰 힙(4GB이상이면 G1, 그 이하면 CMS컬렉터를 사용한다)을 처리하도록 설계되어 있다. CMS컬렉터와 거의 비슷하지만 일반적인 처리를 하는 동안 힙을 압축하고 이동시킬수 있기 때문에 힙의 단편화가 일어날순 있지만 확률이 훨씬 더 낮다. G1컬렉터는 비교적 설계, 구현이 자바 7까지 시험버전이며 자바 8부터 성능상의 이점을 확인했기 때문에 다양한 상황에서 예측하지 못한 상황을 맞닥트릴수 있다.(-XX:+UseG1GC로 활성화)
- System.gc() 메서드를 호출하면 풀gc가 일어나기 때문에 애플리케이션이 잠시 멈추게 되어서 그리 좋은 아이디어는 아니다. 그리고 어차피 일어날 풀GC를 메소드를 호출한 시점으로 호출하는 발생하는 시간대만 옮기기 때문이기도 하다.

- 기본 GC튜닝
- 힙의 크기로 튜닝하는것이 가장 기본이며 힙의 제너레이션 크기에 영향을 준다. 일반적으로 힙의 크기가 너무 작으면 GC가 자주 활동하므로 시간이 많이 걸리고 힙을 너무 크게하면 힙을 정리하는데 걸리는 시간이 많이 걸리므로 절충점이 필요하다.
- 컴퓨터 운영체제는 일반적으로 8GB메모리에서 가상메모리를 두어 12GB가 있는것처럼 보이게 할수 있지만 보여지게 하기 위해서 디스크->메모리, 메모리->디스크로 복사하는 과정이 발생하게 할수 있지만 JVM은 이를 인지 할수 없으므로 힙크기는 실제 물리적인 메모리의 크기만큼만 설정하는 것이 중요하다. JVM은 GC가 너무 자주 일어나면 알아서 알맞은 GC의 크기를 지속적으로 늘릴것이기 때문에 사실상 사용자가 정해진 목표 성능이 없다면 굳이 설정할 필요는 없다.
- 힙의 크기를 정한 후 영 제너레이션과 올드 제네레이션의 할당 크기를 결정한다. 영 제너레이션이 크면 메모리는 덜 수집되고 더 적은 객체가 올드 제너레이션으로 갈것이다. 하지만 올드 제너레이션이 정리되기 때문에 자주 가득차고 풀GC가 자주 일어난다. 이를 위해 균형잡힌 제너레이션 할당이 중요하다.
-  제너레이션의 할당 명령어를 통해 영 제너레이션 설정값을 조절하면 나머지는 올드 제너레이션으로 할당된다. 일반적으로 영제너레이션은 이폴트로 초기 힙 크기의 33%이다. (-XX:NewRatio=N, -XX:NewSize=N, -XXMazNewSize=N)
- 자바7에서 클래스의 메타데이터 정보를 가진 퍼머넌트 제너레이션과 자바 8에서 클래스의 메타데이터 정보를 가진 메타스페이스는 컴파일러와 JVM런 타임에만 사용되며 갖고 있는 데이터는 클래스메타데이터라고 부른다.
- -XX:PermSize=N, -XX:MetaspaceSize=N으로 이 수치를 조절할수 있으며 이들은 초기 크기를 기반으로 동적 크기를 정하고 최대크기에 필요한만큼 자동으로 늘어난다. (->무작정 늘어날 경우 OutOfMemory발생)
- JVM은 적응 크기 조정을 통해 과거의 성능에 의거해 미래에 일어날 GC작업도 과거와 비슷하게 일어날것이라고 판단하고 사용자의 튜닝없이도 스스로 튜닝할수 있음. 튜닝이 이뤄진 후 고정된 튜닝 설정값을 이용하려면 적응 크기 조정을 비활성화 해야된다.

- GC도구 : -XX:+PrintGCTimeStamps, -XX:+PrintGCDateStamps를 통해 GC이벤트가 일어나는 로그를 확인 할 수 있다. GC로그의 양은 로그로테이션을 통해 이를 제한할수 있으며 이를 처리하지않으면 디스크가 부족해 질 수 있다.

