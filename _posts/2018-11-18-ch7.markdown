---
layout: post
title:  "Chapter 07. 힙 메모리 베스트 프랙티스"
date:   2018-11-19 00:00:00 +0900
categories: heap memory best practice
---

# 베스트 프랙티스
* **어떤 객체가 메모리를 소비하고 있는지 파악**
* 객체를 적게 생성, 가능한 빨리 폐기한다
* 특정 종류의 객체가 자주 재생성되면 전반적으로 성능 저하, 재사용하라
  - ex) 쓰레드 로컬 변수, 특별 객체 참조, 객체 풀을 포함 객체 재사용

## 1. 힙 분석
#### 힙 히스토그램 (Heap histogram)
힙 덤프는 분석하는데 시간이 오래 걸리며, 디스크 공간을 많이 차지한다.
전체 힙 덤프 없이 어플리케이션 내 많은 객체를 빨리 살펴볼 수 있는 방법이다.
**특정 객체가 너무 많이 생성되서 발생되는 메모리 부족 이슈는 힙 히스토그램을 이용해 빨리 찾을 수 있다.**

```
$ ps -ef | grep spring                  # pid
$ jcmd pid GC.class_histogram           # 살아있는 객체만 포함
$ jmap -histo pid                       # 죽은 객체 포함
$ jmap -histo pid | grep com.sds.act    # 특정 패키지만 포함
$ jmap -histo:live pid                  # Full GC 강제 실행, 살아있는 객

```

* spring-boot app을 실행해보면 제일 먼저 뜨는게 자바 자료구조 객체, 나머지는 대부분 spring 어플리케이션이 뜨는데 필요한 객체들
이 사이에 Controller, Service, Repository 또는 직접 설계한 객체가 많은 메모리를 사용하면 튜닝의 대상이 된다.


## 2. 힙 덤프
히스토그램은 한두개 특정 클래스의 인스턴스를 너무 많이 할당하면서 일으키는 이슈를 파악하기는 좋으나 심도 있는 분석을 위해서는 힙 덤프 필요
**메모리 사용량을 찾아 낼 수 있는 가장 강력한 기술이다.**

```
$ jmap -dump:live,file=/path/to/heap_dump.hprof pid
$ jcm pid GC.heap_dump /path/to/heap_dump.hprof     # mac에서 실패
```

```
생성된 덤프 파일 연결
$ jhat {dump 파일 경로}                     # http 서버로 실행, 브라우저에서 확인가능
$ jvisualvm --openfile {dump 파일 경로}     # jhat보다 기능이 많아서 더 보기 쉽다. 쿼리를 날려서 결과가능하나 쿼리 공부해야한다

개인적으로 jhat보다 jvisualvm 사용할것 같고,  [mat](https://www.eclipse.org/mat/)은 사용한적이 없다. 기능만 봤을때는 jvisualvm과 유사할듯하다
```

#### 얕은 객체 vs 깊은 객체 크기
* 얕다 (shallow) 객체 자체의 크키, 객체가 다른 객체 참조를 갖고 있다면 참조가 포함되지만 대상 객체의 크기는 포함되지 않는다.
* 깊은 (deep) 객체 크기는 객체들의 크기 포함

* 힙의 지배자(dominator) : 커다란 힙 공간을 보유한 객체
  - 힙의 지배자 객체 덜 생성, 짧은 기간만 보유, 객체 그래프 탐색 단순화, 더 작게 만들기
  - 보통 클래스 로더 크기 가장 크고, 제어할 수 없다.

* GC 루트로 바로 접근한 하는 것이 반드시 유용한 것은 아니다.
  - 대상 객체를 참조하는 스태틱, 글로벌 참조 일부를 가진 시스템 객체
  - 시스템이나 부트스트랩 클래스 패스로 로드된 클래스이 스태틱 변수에서 비롯된다.
  - Thread 클래스, 모든 활성 스레드 포함


## 3. 메모리부족 에러
* native memory
  - 32bit JVM 프로세스의 최대크기는 4GB
* 퍼머넌트 제너레이션, 메타스페이스 부족
  - 자바7 퍼버먼트 제너레이션 부족:  더 많은 클래스 사용
  - 자바8 메사스페이스 네이티브 메모리 꽉 차서 발생
