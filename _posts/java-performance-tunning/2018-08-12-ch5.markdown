---
layout: post
title:  "Chapter 05. 가비지 컬렉션 입문"
date:   2018-08-11 21:30:28 +0900
categories: java performance tuning
---
### 가비지 컬렉터 개요

- 최근 버전의 JVM은 시리얼 컬렉터, 처리율 컬렉터, 동시병렬 컬렉터, G1컬렉터로 나뉘어 진다.
- 가비지 컬렉터는 멀티스레드를 사용하며 두개의 논리적인 스레드 그룹이 존재한다. 각각 애플리케이션 로직과 GC를 수행하며 GC스레드가 객체 참조를 추적하거나 메모리에 객체를 옮기면 애플리케이션 스레드가 그 객체들을 사용하고 있지 않는다는 사실을 증명하는 역할을 한다.
- 애플리케이션 스레드가 동작하면서 일부 부분집합으로 쪼개어진 힙이 메모리 영역을 모두 사용하면 더 이상 사용하지 않는 메모리를 사용하고 있는 메모리의 인접 메모리로 이동 후 이동한 주소 포인트를 가리킨다.
- 나눠진 영역없이 모든 애플리케이션 스레드를 모두 중지한후 사용되지 않는 객체를 찾아서 메모리를 해제하고 메모리 파편화를 방지하기 위해 힙을 압축하는 과정을 풀GC라고 부른다.
- 생명주기가 짧은 객체가 저장되는 힙 영역을 '영 제너레이션'이라고하며 해당영역에서 발생하는 GC를 Minor GC라고 한다. 생명주기가 긴 객체가 저장되는 힙 영역을 '올드 제너레이션'이라고 하며 해당영역에서 발생하는 GC를 Major GC라고 한다.
- CMS와 G1 컬렉터는 미사용 객체를 훑어보는 동안 애플리케이션 스레드를 멈추지 않고 처리하기 때문에 동시 병렬 컬렉터라고 부르며 저중단 컬렉터라고도 부른다. 다만 CPU사용율이 늘어나는 것이 기존의 컬렉터(애플리케이션 스레드 중단 시간) 와의 트레이드 오프 이다.

### GC알고리즘

1. 시리얼 컬렉터 
- 싱글 스레드일경우 가장 기본적으로 사용되는 가비지 컬렉터이며 메모리를 해제 시키기 위한 스레드가 수행되기 위해선 애플리케이션 스레드가 멈춰있는다. (-XX:+UseSerialGC로 활성화)
2. 처리율 컬렉터 
- 다중CPU유닉스 머신이나 64비트 JVM에서 디폴트 컬렉터이다. 영 제네레이션을 처리할때 여러개의 스레드를 사용하기 때문에 Minor GC가 빨라진다.올드 제너레이션을 처리할때도 여러개의 스레드를 사용할 수 있으며 Minor GC든 풀GC이든 모든 애플리케이션 스레드를 멈춘다. (-XX:+UseParallelOldGC로 활성화)
3. CMS컬렉터 
- CMS컬렉터는 Minor GC동안 애클리케이션 스레드를 전부 중지 시키고 여러개의 스레드로 수행한다. 풀GC동안은 애플리케이션 스레드를 멈추지 않고 주기적으로 올드 제너레이션을 살피고 미사용 개체를 폐기하는데 하나 이상의 백그라운드 스레드를 사용한다. 하지만 주기적으로 올드 제네레이션을 관찰하고 폐기하고 애플리케이션 스레드가 돌기 때문에 CPU사용율이 높다. (-XX:+UseConcMarkSweepGC, -XX:+UseParNewGC로 활성화)
4. G1컬렉터
- 큰 힙(4GB이상이면 G1, 그 이하면 CMS컬렉터를 사용한다)을 처리하도록 설계되어 있다. CMS컬렉터와 거의 비슷하지만 일반적인 처리를 하는 동안 힙을 압축하고 이동시킬수 있기 때문에 힙의 단편화가 일어날순 있지만 확률이 훨씬 더 낮다. G1컬렉터는 비교적 설계, 구현이 자바 7까지 시험버전이며 자바 8부터 성능상의 이점을 확인했기 때문에 다양한 상황에서 예측하지 못한 상황을 맞닥트릴수 있다.(-XX:+UseG1GC로 활성화)
- System.gc() 메서드를 호출하면 풀gc가 일어나기 때문에 애플리케이션이 잠시 멈추게 되어서 그리 좋은 아이디어는 아니다. 그리고 어차피 일어날 풀GC를 메소드를 호출한 시점으로 호출하는 발생하는 시간대만 옮기기 때문이기도 하다.

### 기본 GC튜닝

- 힙의 크기로 튜닝하는것이 가장 기본이다. 일반적으로 힙의 크기가 너무 작으면 GC가 자주 활동하므로 시간이 많이 걸리고 힙을 너무 크게하면 힙을 정리하는데 걸리는 시간이 많이 걸리므로 절충점이 필요하다.
- 컴퓨터 운영체제는 물리적인 8GB메모리에서 가상메모리를 두어 12GB가 있는것처럼 보이게 할수 있지만 보여지게 하기 위해서 디스크->메모리, 메모리->디스크로 복사하는 과정이 발생한다. JVM은 이를 인지 할수 없으므로 힙크기는 실제 물리적인 메모리의 크기만큼만 설정하는 것이 중요하다. JVM은 GC가 너무 자주 일어나면 알아서 알맞은 GC의 크기를 지속적으로 늘릴것이기 때문에 사실상 사용자가 정해진 목표 성능이 없다면 굳이 설정할 필요는 없다.
- 힙의 크기를 정한 후 영 제너레이션과 올드 제네레이션의 할당 크기를 결정한다. 영 제너레이션이 크면 메모리는 덜 수집되고 더 적은 객체가 올드 제너레이션으로 갈것이다. 하지만 올드 제너레이션이 정리되기 때문에 자주 가득차고 풀GC가 자주 일어난다. 이를 위해 균형잡힌 제너레이션 할당이 중요하다.
-  제너레이션의 할당 명령어를 통해 영 제너레이션 설정값을 조절하면 나머지는 올드 제너레이션으로 할당된다. 일반적으로 영제너레이션은 디폴트로 초기 힙 크기의 33%이다. (-XX:NewRatio=N, -XX:NewSize=N, -XXMazNewSize=N)
- JVM이 클래스들을 로드할때 클래스들의 메타 정보를 파악하는 힙공간이 있는데 자바7에서 이를 퍼머넌트 제너레이션이라고 불리고 자바 8에서는 메타스페이스라고 부른다.  
- 퍼머넌트 제너레이션과 메타스페이스는 각각  -XX:PermSize=N, -XX:MetaspaceSize=N 으로 이 수치를 조절할수 있으며 이들은 초기 크기를 기반으로 동적 크기를 정하고 최대크기에 필요한만큼 자동으로 늘어난다. (->무작정 늘어날 경우 OutOfMemory발생)
- JVM은 적응 크기 조정을 통해 과거의 성능에 의거해 미래에 일어날 GC작업도 과거와 비슷하게 일어날것이라고 판단하고 사용자의 튜닝없이도 스스로 튜닝할수 있음. 튜닝이 이뤄진 후 고정된 튜닝 설정값을 이용하려면 적응 크기 조정을 비활성화 해야된다.
- GC도구 : -XX:+PrintGCTimeStamps, -XX:+PrintGCDateStamps를 통해 GC이벤트가 일어나는 로그를 확인 할 수 있다. GC로그의 양은 로그로테이션을 통해 이를 제한할수 있으며 이를 처리하지않으면 디스크가 부족해 질 수 있다.

#### 참고할만한 사이트
<https://yenaworldblog.wordpress.com/2017/11/01/가비지-컬렉션-입문/>
<http://www.holaxprogramming.com/2013/07/20/java-jvm-gc/>